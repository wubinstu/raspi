1.epoll初始化新连接的客户端套接字性能底下(epoll模型调用顺序, 使用注意事项)
    解决: 客户端套接字设置为非阻塞态 UUID协商过程移出初始化, 放在下一个事件循环中处理
    SSL握手过程移出初始化(SSL_accept 需要多次读写套接字), 放在下一个事件循环中处理

2.thread_pool内存性能优化
    解决:预先分配好内存,而不是用一次分配一次

3.每发送一个数据包就断开一次连接重现建立连接
    解决: 服务器发送心跳数据包为客户端保活,防止客户端高频复位

4.UUID协商, 服务器非阻塞SSL_write函数先于客户端阻塞SSL_read函数调用, 发生死锁
    解决: (烂办法)调用客户端调用sleep函数等待一段时间后再调用SSL_read函数
    对于服务器而言,接收uuid数据和鉴别,分配,发送uuid处于同一个事件循环,因此理论上很快就会调用SSL_write

5.客户端由于断电,SIGKILL信号等事件发生急停,服务器由于不能收到心跳数据包"FIN"而释放客户端信息
    解决:利用TCP的KeepAlive机制和 epoll 函数提供的 EPOLLHUP,EPOLLRDHUP, EPOLLERR 等事件完成客户端的释放

6.客户端的心跳数据包"FIN"慢了一步,被服务器判定为客户端非正常退出
    解决:移除该心跳数据包机制, 客户端信息释放全部由epoll管理, 降低程序复杂性

7.sql_pool_conn_release函数归还连接后原指针仍然可以继续访问sql连接
    解决: 修改函数定义, 运用二级指针, 归还连接后将指针归为NULL

8.客户端拿到UUID向本地文件记录时总是写全0
    解决: memset函数将数据清零了, 将memset函数位置进行调整

9.客户端软件多开压力测试中, 发现连接池分配出现漏洞, 很多客户端在初始化时由于池满不能得到有效连接
    解决: 不再在初始化时分配sql连接, 更改为真正数据交互时 需要写入数据库时申请数据库连接并且用完立即归还连接

10.压力测试中, 服务器分配的客户端套接字都是奇数, 但如果客户端一个一个慢慢连接就没事
    解释: 在SSL/TLS握手过程中, 会涉及到大量的随机数生成操作, 这些随机数通常是使用操作系统提供的随机数生成器生成的
    在Linux中, 这个随机数生成器通常是通过读取/dev/urandom设备实现的
    而/dev/urandom设备使用熵池来生成随机数, 当系统启动时熵池通常会初始化为一些随机的值
    然后在运行过程中不断从各种事件(如键盘,鼠标,磁盘I/O等)中收集熵, 用于生成更多的随机数
    因此当有大量的客户端连接时, SSL握手过程需要频繁地使用随机数生成器, 这可能会消耗系统中的熵池
    如果熵池中的熵不足, /dev/urandom设备可能会被阻塞, 直到足够的熵被积累
    这可能会导致一些套接字文件描述符被暂时保留, 以便随机数生成器在/dev/urandom设备中生成足够的随机数

    补充: 非SSL连接也会出现同样的问题, 经过分析, 每个客户端连接都会被服务器分配两个套接字
    进一步排查: 只有使用本人开发的 "客户端多开" 压力测试软件才会出现这个问题, 即使多开的数量为 1, 也会被分配两个套接字
    解决: [忽略] 非服务器主体功能问题, 即使被分配了两个套接字, 但经过测试这它们都会被正常释放
